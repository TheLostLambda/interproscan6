# `InterProScan` Output

This doc describes the architecture and data contained within the output files of `InterProScan6`. The output data from `InterProScan5` is also described to assist with the development of `InterProScan` version 6.

## `InterProScan-6` `TSV` Output:

:TO-DO:

## `InterProScan-6` `JSON` Output:

:TO-DO:

## `InterProScan-5` `TSV` Output:

1. Sequence identifier
2. Sequence MD5 checksum (lower casse)
3. Sequence length
4. Member database name
5. Member database signature accession
6. Member database signature description, name, or "-"
7. Match location start
8. Match location end
9. Score
    * e-value for AntiFam, CATH-Gene3D (+ FunFam), NCBIfam, PANTHER, Pfam, PIRSF, PRINTS, SFLD, SMART, SUPERFAMILY,
    * score for HAMAP, PROSITE Profiles
    * `-` for Coils, MobiDB-lite,  Phobius, PROSITE Patterns, SignalP, TMHMM
10. Status (always `T`)
11. Date (format: `DD-MM-YYYY`)
12. InterPro entry or `-` (unintegrated)
13. InterPro description or `-` (unintegrated)
14. Pipe-separated list of GO terms, or `-` if none. Each GO term follows the format `GO:XXXXXXX(source)`, where `source` is the provider. It can be `InterPro`, `Panther`, or `InterPro,PANTHER`.
15. Pipe-separated list of pathways, or `-` if none. Each pathway follows the format `Source:identifier`. Currently, the possible sources are `MetaCyc` and `Reactome`.

Example:

```
UPI0004FABBC5	92e4b89dd86f8ab828f57121f6d7d460	257	PRINTS	PR01914 Neurotrophin-3 signature	81	95	2.0E-26	T	28-03-2024	IPR015578	Neurotrophin-3	GO:0005165(InterPro)	Reactome:R-BTA-9034013|Reactome:R-BTA-9034793|Reactome:R-BTA-9603381|Reactome:R-HSA-9025046|Reactome:R-HSA-9034013|Reactome:R-HSA-9034015|Reactome:R-HSA-9034793|Reactome:R-HSA-9034864|Reactome:R-HSA-9603381|Reactome:R-MMU-9034013|Reactome:R-MMU-9034793|Reactome:R-MMU-9603381|Reactome:R-RNO-9034013|Reactome:R-RNO-9034793|Reactome:R-RNO-9603381
```

## `InterProScan-5` `JSON` Output:

For each input/query sequence:
* `sequence`: the protein sequence
* `md5`: MD5 hash of the protein sequence
* `matches`: list of matches from pre-calculated matches and matches generated by the analysis. Specifically, it is a list of dicts, each dict representing a match. For each match:
    * `evalue`: overall, full sequence evalue
    * `score`: overall, full sequence bit-score
    * `model-ac`: signature accession --> but this is already stored under the `signature`:`accession` keys.
    * `signature`: dict summarising the InterPro signature
        * `accession`: signature accession
        * `name`: shortname from InterPro
        * `description`: long name from InterPro
        * `entry`: The accession of the InterPro entry that the signature is associated with
        * `signatureLibraryRelease`: dict {`library`: application name, `version`: release version number}
    * `locations` : list of locations where the signature matched the protein sequence. Specifically, a list of dicts, one dict per location where a match between the protein sequence and signature was found. Therefore, each dict is a domain hit, and for each domain hit:
        * `start` start location of domain -- listed as "**ali** coord **from**" in `hmmer.dtbl`
        * `end` end location of domain -- listed as "**ali** coord **to**" in `hmmer.dtbl`
        * `hmmStart` start location of hmm? -- listed as "**hmm** coord **from**" in `hmmer.dtbl`
        * `hmmEnd` end location of hmm? -- listed as "**hmm** coord **to**" in `hmmer.dtbl`
        * `evalue`: domain evalue
        * `score`: bitscore
        * `envelopesStart`: start of envelop (the envelope is the region or range of the protein sequence were the domain may be located) -- listed as "**env** coord **from**" in `hmmer.dtbl`
        * `envelopeEnd`: end of envelop -- listed as "**env** coord **to**" in `hmmer.dtbl`
        * `location-fragments` -- list of dicts, one dict per fragment:
            * `start` - _The start and end match up with the **ali cord** from and to, but would this not make the data redudnant?
            * `end` 
            * `dc-status` - ???
        * `sites`: list of dicts, one dict per site (a domain signature can have multiple sites). Per site:
            * `description`: site description (from InterPro)
            * `numLocations`: The number of locations (it is the same as the lengh of `siteLocations` - so do we need it?)
            * `label`: ???
            * `group`: ????
            * `hmmStart`: ???? -- surely not relevant here as detection of the site is not determined by the HMM model but by post-processing of the hits and checking the alignemnts
            * `hmmEnd`: ???? -- surely not relevant here as detection of the site is not determined by the HMM model but by post-processing of the hits and checking the alignemnts    
            * `siteLocations`: list, one dict per location:
                * `start`: int
                * `end`: int
                * `residue`: char

Example output file: `ips5-sfld-output.json`
example: A0A0H3E4R3_BACA1
